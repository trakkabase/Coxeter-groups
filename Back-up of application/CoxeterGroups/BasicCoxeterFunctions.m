(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: BasicCoxeterFunctions` *) 
(* :Author: David Sheard *)
(* :Summary: Basic functions to define and manipulate Coxeter systems. *)
(* :Context: CoxeterGroups`BasicCoxeterFunctions` *)
(* :Package version: 1.0 *)
(* :History:  Version 1.0 February 19 2022 *)
(* :Mathematica version: 12.0.0 for Microsoft Windows (64-bit) (April 6, 2019) *)
(* :Discussion: Give more details here.*)


BeginPackage["CoxeterGroups`BasicCoxeterFunctions`"];


Unprotect[
(*Coxeter matrix and Coxeter form*)
ValidCoxeterMatrixQ,BilinearForm, FormSignature,
(*Special Subgroups*)
Generators, DiagramNeighbours,ConnectedComponentUnionQ,IrreducibleFactor,IrreducibleCGQ,SpecialSubgroup,ConvertToSpecialSubgroup,ConvertFromSpecialSubgroup,IrreducibleFactorComplement,IrreducibleFactors,IrreducibleSpecialSubgroups,SpecialSubgroups,SphericalSubgroups,
(*Types of Coxeter system*)
EuclideanCGQ, SphericalCGQ,HyperbolicCGQ,EvenCGQ,RACGQ,
(*Coxeter system data*)
GroupSize,MaxLength,CoxeterNumber,DavisComplexDimension,
(*Group element storage*)
StringCharacters, ValidCharacters, ValidFileNameQ,NamedQ,ElementDirName, ElementDirExistQ,CreateElementDir,ExportElementList,LengthEnumerated,EnumeratedQ,SmoothDirName, SmoothDirExistQ,CreateSmoothDir,ExportSmoothList,SmoothEnumeratedQ,
(*Examples of Coxeter matrices*)
SymmetricEntry,TypeA,TypeB,TypeC,TypeD,E6,E7,E8,F4,G2,H3,H4,I2,TypeAE,TypeAE,TypeAE,TypeAE,EE6,EE7,EE8,FE4,GE2,TriangleCG,FreeCG,RAPolygonG,RABipartiteG,RACGroup
];
ClearAll[
(*Coxeter matrix and Coxeter form*)
ValidCoxeterMatrixQ,BilinearForm, FormSignature,
(*Special Subgroups*)
Generators, DiagramNeighbours,ConnectedComponentUnionQ,IrreducibleFactor,IrreducibleCGQ,SpecialSubgroup,ConvertToSpecialSubgroup,ConvertFromSpecialSubgroup,IrreducibleFactorComplement,IrreducibleFactors,IrreducibleSpecialSubgroups,SpecialSubgroups,SphericalSubgroups,
(*Types of Coxeter system*)
EuclideanCGQ, SphericalCGQ,HyperbolicCGQ,EvenCGQ,RACGQ,
(*Coxeter system data*)
GroupSize,MaxLength,CoxeterNumber,DavisComplexDimension,
(*Group element storage*)
StringCharacters, ValidCharacters, ValidFileNameQ,NamedQ,ElementDirName, ElementDirExistQ,CreateElementDir,ExportElementList,LengthEnumerated,EnumeratedQ,SmoothDirName, SmoothDirExistQ,CreateSmoothDir,ExportSmoothList,SmoothEnumeratedQ,
(*Examples of Coxeter matrices*)
SymmetricEntry,GroupName,TypeA,TypeB,TypeC,TypeD,E6,E7,E8,F4,G2,H3,H4,I2,TypeAE,TypeAE,TypeAE,TypeAE,EE6,EE7,EE8,FE4,GE2,TriangleCG,FreeCG,RAPolygonG,RABipartiteG,RACGroup
];


ValidCoxeterMatrixQ::usage="ValidCoxeterMatrixQ[M] returns True if M is a Coxeter matrix, and False otherwise.";
BilinearForm::usage="BilinearForm[M] returns the bilinear form associated to the Coxeter matrix M."; 
FormSignature::usage="FormSugnature[A] returns the signature of the form A in the form of a list {"<>ToString[Subscript["n","+"],FormatType->StandardForm]<>","<>ToString[Subscript["n","0"],FormatType->StandardForm]<>","<>ToString[Subscript["n","-"],FormatType->StandardForm]<>"}.";


Generators::usage="Generators[M] gives an ordered list of the Coxeter generators of the Coxeter system with matrix M, each generator being of the form \"i\" for some integer i.";
DiagramNeighbours::usage="DiagramNeighbours[M,s] gives an ordered all generators which are adjacent to s in the Coxeter diagram of type M (including s).
DiagramNeighbours[M,{s1,s2,...}] lists all generators which are adjacent to some s in {s1,s2,...} in the Coxeter diagram of type M (including s1, s2,...).";
ConnectedComponentUnionQ::usage="ConnectedComponentUnionQ[M,{s1,s2,...}] returns True if {s1,s2,...} represents the set of vertices of a union of connected components of the Coxeter diagram of type M, and False otherwise.";
IrreducibleFactor::usage="IrreducibleFactor[M,s] returns the list of all vertices in the connected component of the Coxeter diagram of type M.";(*This function privately also takes inputs of the form [M,{s1,s2,...}] but assumes a priori that {s1,s2,...} all lie in the same connected component.*)
IrreducibleCGQ::usage="IrreducibleCGQ[M] returns True if M represents an irreducible Coxeter system, and False otherwise.";
SpecialSubgroup::usage="SpecialSubgroup[M,{s1,s2,...}] returms the pair {N,sList}, where sList=Sort[{s1,s2,...}], and N is the Coxeter matrix of the special subgroup generated by sList.";
IrreducibleFactors::usage="IrreducibleFactors[M] returs a list of the sets of generators in each irreducible special subgroup of W(M).";
IrreducibleSpecialSubgroups::usage="IrreducibleSpecialSubgroups[M] returns a list of all the irreducible special subgroups of W(M), each in the form {N,sList} where N is the Coxeter matrix, and sList is the list of generators for W(N).";
SpecialSubgroups::usage="SpecialSubgroups[M] returns a list of all non-trivial special subgroups of the Coxeter system with the Coxeter matrix M.";
SphericalSubgroups::usage="SpericalSubgroups[M] returns a list of all non-trivial finite special subgroups of the Coxeter system with the Coxeter matrix M.";


EuclideanCGQ::usage="EuclideanCGQ[M] returns True if W(M) is a Euclidean Coxeter group, ie it acts discretely by isometries on some Euclidean space, and False otherwise.";
SphericalCGQ::usage="SphericalCGQ[M] returns True if W(M) is finite, and False otherwise.";
HyperbolicCGQ::usage="HyperbolicCGQ[M] returns True if W(M) is a hyperbolic Coxeter group, ie the signature of its bilinear form is (n-1,0,1), and False otherwise.";
EvenCGQ::usage="EvenCGQ[M] returns True if every edge lable in the Coxeter diagram of type M is even, and False otherwise.";
RACGQ::usage="RACGQ[M] returns True if M corresponds to a right-angled Coxeter system, and False otherwise.";


GroupSize::usage="GroupSize[M] returns the cadinality of the Coxeter group whose Coxeter matrix is M";
MaxLength::usage="MaxLength[M] returns the length of the unique longest element in the Coxeter group whose Coxeter matrix is M if M is spherical type, and \[Infinity] otherwise.";
CoxeterNumber::usage="CoxeterNumber[M] returns the order of the Coxeter element of the Coxeter system associated to M. Unless M has spherical type, this is \[Infinity]."
DavisComplexDimension::usage="DavisComplexDimension[M] returns the dimension of the Davis complex associated to the Coxeter system with Coxeter matrix M.";


StringCharacters::usage="StringCharachters[str] returns a list of the unique charachters which appear in str.";
ValidCharacters::usage="List of the allowable characters in a file name."; 
ValidFileNameQ::usage="ValidFileNameQ[str] returns True if str contains only characters from the list ValidCharacters, and False otherwise.";
NamedQ::usage="NamedQ[M] returns True if GroupName[M] has been defined as a String, and False otherwise.";
ElementDirName::usage="ElementDirName[M] gives the file path for the directory containing the enumerated group emements for the Coxeteter system with matrix M.";
ElementDirExistQ::usage="ElementDirExistsQ[M] returns True if the directory with path ElementDirName[M] exists, False otherwise.";
CreateElementDir::usage="CreateElementDir[M] creates the directory with path ElementDirName[M].";
ExportElementList::usage="ExportElementList[M,{k},wordList] saves the list wordList to a file in the directory with path ElementDirName[M] with name \"k.mx\".";
LengthEnumerated::usage="LengthEnumerated[M] gives the maximum natural number such that all group elements of W(M) up to that length ahve been previously computed. If no elements have been computed it takes value -1.";
EnumeratedQ::usage="EnumeratedQ[M,k] returens True if LengthEnumerated[M] is at most k, and False otherwise.";
SmoothDirName::usage="SmoothDirName[M] gives the file path for the directory containing the smooth group emements for the Coxeteter system with matrix M which have been enumerated.";
SmoothDirExistQ::usage="SmoothDirExistsQ[M] returns True if the directory with path SmoothDirName[M] exists, False otherwise.";
CreateSmoothDir::usage="CreateSmoothDir[M] creates the directory with path SmoothDirName[M].";
ExportSmoothList::usage="ExportSmmothList[M,{k},wordList] saves the list wordList to a file in the directory with path SmoothDirName[M] with name \"k.mx\".";
SmoothEnumeratedQ::usage="SmoothEnumeratedQ[M,{k}] returens True if there is a file in the directory SmoothDirName[M] with mane \"k.mx\", and False otherwise.";


GroupName::usage="GroupName[M] returns the name of the Coxeter system with matric M as a string. This is used for file naming when storing enumerated elements.";
TypeA::usage="TypeA[n] returns the Coxeter matrix of type "<>ToString[Subscript["A","n"],FormatType->StandardForm]<>".";
TypeB::usage="TypeB[n] returns the Coxeter matrix of type "<>ToString[Subscript["B","n"],FormatType->StandardForm]<>".";
TypeC::usage="TypeC[n] returns the Coxeter matrix of type "<>ToString[Subscript["C","n"],FormatType->StandardForm]<>".";
TypeD::usage="TypeD[n] returns the Coxeter matrix of type "<>ToString[Subscript["D","n"],FormatType->StandardForm]<>".";
E6::usage="E6 returns the Coxeter matrix of type "<>ToString[Subscript["E","6"],FormatType->StandardForm]<>".";
E7::usage="E7 returns the Coxeter matrix of type "<>ToString[Subscript["E","7"],FormatType->StandardForm]<>".";
E8::usage="E8 returns the Coxeter matrix of type "<>ToString[Subscript["E","8"],FormatType->StandardForm]<>".";
F4::usage="F4 returns the Coxeter matrix of type "<>ToString[Subscript["F","4"],FormatType->StandardForm]<>".";
G2::usage="G2 returns the Coxeter matrix of type "<>ToString[Subscript["G","2"],FormatType->StandardForm]<>".";
H3::usage="H3 returns the Coxeter matrix of type "<>ToString[Subscript["H","3"],FormatType->StandardForm]<>".";
H4::usage="H4 returns the Coxeter matrix of type "<>ToString[Subscript["H","4"],FormatType->StandardForm]<>".";
I2::usage="I2[m] returns the Coxeter matrix of type "<>ToString[Subscript["I","2"],FormatType->StandardForm]<>"(m).";
TypeAE::usage="TypeEA[n] returns the Coxeter matrix of type "<>ToString[Subscript[OverTilde["A"],"n+1"],FormatType->StandardForm]<>".";
TypeBE::usage="TypeEB[n] returns the Coxeter matrix of type "<>ToString[Subscript[OverTilde["B"],"n+1"],FormatType->StandardForm]<>".";
TypeCE::usage="TypeEC[n] returns the Coxeter matrix of type "<>ToString[Subscript[OverTilde["C"],"n+1"],FormatType->StandardForm]<>".";
TypeDE::usage="TypeED[n] returns the Coxeter matrix of type "<>ToString[Subscript[OverTilde["D"],"n+1"],FormatType->StandardForm]<>".";
EE6::usage="EE6 returns the Coxeter matrix of type "<>ToString[Subscript[OverTilde["E"],"6"],FormatType->StandardForm]<>".";
EE7::usage="EE7 returns the Coxeter matrix of type "<>ToString[Subscript[OverTilde["E"],"7"],FormatType->StandardForm]<>".";
EE8::usage="EE8 returns the Coxeter matrix of type "<>ToString[Subscript[OverTilde["E"],"8"],FormatType->StandardForm]<>".";
FE4::usage="FE4 returns the Coxeter matrix of type "<>ToString[Subscript[OverTilde["F"],"4"],FormatType->StandardForm]<>".";
GE2::usage="GE2 returns the Coxeter matrix of type "<>ToString[Subscript[OverTilde["G"],"2"],FormatType->StandardForm]<>".";
TriangleCG::usage="TriangleCG[p,q,r] return the Coxeter matrix of rank 3 with off-diagonal entries p,q,r.";
RACGroup::usage="RACGroup[A] returns the Coxeter matric of the right-angled Coxeter Group associated to the graph with adjacency matrix A.";
FreeCG::usage="FreeCG[n] returns returns the Coxeter matrix of the free Coxter group of rank n.";
RAPolygonG::usage="RAPolygonG[n] returns returns the Coxeter matrix of the Coxter group which acts on the hyperbolic plane with fundamental chamber a right-angled polygon with n sides.";
RABipartiteG::usage="RABipartiteG[m,n] returns returns the Coxeter matrix of the right-angled Coxter group assocoated to the bipartite graph "<>ToString[Subscript["K","m,n"],FormatType->StandardForm]<>".";


ValidCoxeterMatrixQ::argerr="One matrix argument expected."; 
BilinearForm::argerr="One matrix argument expected."; 
FormSignature::argerr="One matrix argument expected.";


Generators::argerr="One matrix argument expected.";
DiagramNeighbours::argerr="Two arguments expected.";
ConnectedComponentUnionQ::argerr="Two arguments expected.";
IrreducibleFactor::argerr="Two arguments expected.";
IrreducibleCGQ::argerr="One matrix argument expected.";
SpecialSubgroup::argerr="Two arguments expected.";
IrreducibleFactors::argerr="One matrix argument expected.";
IrreducibleSpecialSubgroups::argerr="One matrix argument expected.";
SpecialSubgroups::argerr="One matrix argument expected.";
SphericalSubgroups::argerr="One matrix argument expected.";


EuclideanCGQ::argerr="One matrix argument expected.";
SphericalCGQ::argerr="One matrix argument expected.";
HyperbolicCGQ::argerr="One matrix argument expected.";
EvenCGQ::argerr="One matrix argument expected.";
RACGQ::argerr="One matrix argument expected.";


GroupSize::argerr="One matrix argument expected.";
MaxLength::argerr="One matrix argument expected.";
CoxeterNumber::argerr="One matrix argument expected.";
DavisComplexDimension::argerr="One matrix argument expected.";


StringCharacters::argerr="One string argument expected.";
ValidFileNameQ::argerr="One string argument expected.";
ValidCharacters::argerr="No arguments expected.";
NamedQ::argerr="One matrix argument expected.";
ElementDirName::argerr="One matrix argument expected.";
ElementDirExistQ::argerr="One matrix argument expected.";
CreateElementDir::argerr="One matrix argument expected.";
ExportElementList::argerr="Three arguments expected.";
LengthEnumerated::argerr="One matrix argument expected.";
EnumeratedQ::argerr="Two arguments expected.";
SmoothDirName::argerr="One matrix argument expected.";
SmoothDirExistQ::argerr="One matrix argument expected.";
CreateSmoothDir::argerr="One matrix argument expected.";
ExportSmoothList::argerr="Three arguments expected.";
SmoothEnumeratedQ::argerr="Two arguments expected.";


GroupName::argerr="One matrix argument expected.";
GroupName::undefined="You must declare a name for the group `1` as a string: groupName[`1`]=\"name\".";
GroupName::invalidGroupName="A the groupName must be a string containing the following characters only: upper and lower case Roman letters, Arabic numerals, spaces, or any of the following -_,.()";
TypeA::argerr="One number expected.";
TypeB::argerr="One number expected.";
TypeC::argerr="One number expected.";
TypeD::argerr="One number expected.";
I2::argerr="One number expected.";
TypeAE::argerr="One number expected.";
TypeAE::argerr="One number expected.";
TypeAE::argerr="One number expected.";
TypeAE::argerr="One number expected.";
TriangleCG::argerr="Three numbers expected.";
FreeCG::argerr="One number expected.";
RAPolygonG::argerr="One number expected.";
RABipartiteG::argerr="Two numbers expected.";
RACGroup::argerr="One matrix argument expected.";
RACGroup::argtype="Argument must be a symmetric matrix of 1's and 0's.";


Begin["`Private`"];


ValidCoxeterMatrixQ[args___]:=(Message[ValidCoxeterMatrixQ::argerr];$Failed)
BilinearForm[args___]:=(Message[BilinearForm::argerr];$Failed)
FormSignature[args___]:=(Message[FormSignature::argerr];$Failed)


ValidCoxeterMatrixQ[M_]:=SymmetricMatrixQ[M]&&Fold[And,M[[#]][[#]]==1&/@Range[Length[M]]]&&Fold[And,(Head[#]==Integer||Head[#]==DirectedInfinity)&&#>0&/@DeleteDuplicates[Flatten[M]]]


BilinearForm[M_]:=Table[Table[-Cos[Pi/M[[i]][[j]]],{j,Length[M]}],{i,Length[M]}] (*gives the canonical bilinear form associated to Coxeter matrix M*)


FormSignature[A_]:={Length[Select[Chop[Eigenvalues[A]],#>0&]],Length[Select[Chop[Eigenvalues[A]],#==0&]],Length[Select[Chop[Eigenvalues[A]],#<0&]]}


Generators[args___]:=(Message[Generators::argerr];$Failed)
DiagramNeighbours[args___]:=(Message[DiagramNeighbours::argerr];$Failed)
ConnectedComponentUnionQ[args___]:=(Message[ConnectedComponentUnionQ::argerr];$Failed)
IrreducibleFactor[args___]:=(Message[IrreducibleFactor::argerr];$Failed)
IrreducibleCGQ[args___]:=(Message[IrreducibleCGQ::argerr];$Failed)
SpecialSubgroup[args___]:=(Message[SpecialSubgroup::argerr];$Failed)
IrreducibleFactors[args___]:=(Message[IrreducibleFactors::argerr];$Failed)
IrreducibleSpecialSubgroups[args___]:=(Message[IrreducibleSpecialSubgroups::argerr];$Failed)
SpecialSubgroups[args___]:=(Message[SpecialSubgroups::argerr];$Failed)
SphericalSubgroups[args___]:=(Message[SphericalSubgroups::argerr];$Failed)


(* ::Input::Initialization:: *)
Generators[M_]:=Table[ToString[i],{i,1,Length[M]}]


(* ::Input::Initialization:: *)
DiagramNeighbours[M_,s_String]:=Sort[Select[Generators[M],Not[M[[ToExpression[s]]][[ToExpression[#]]]==2]&]]
DiagramNeighbours[M_,sList_List]:=Sort[DeleteDuplicates[Flatten[Join[DiagramNeighbours[M,#]&/@sList]]]]


(* ::Input::Initialization:: *)
ConnectedComponentUnionQ[M_,sList_List]:=Sort[sList]==DiagramNeighbours[M,sList]


(* ::Input::Initialization:: *)
IrreducibleFactor[M_,s_String]:=If[ConnectedComponentUnionQ[M,{s}],{s},IrreducibleFactor[M,DiagramNeighbours[M,s]]]
IrreducibleFactor[M_,sList_List]:=If[ConnectedComponentUnionQ[M,sList],sList,IrreducibleFactor[M,DiagramNeighbours[M,sList]]]


(* ::Input::Initialization:: *)
IrreducibleCGQ[M_]:=IrreducibleFactor[M,"1"]==Generators[M]


(* ::Input::Initialization:: *)
SpecialSubgroup[M_,sList_List]:={Join[M[[#]]&/@ToExpression[Sort[sList]]][[All,#]]&/@ToExpression[Sort[sList]],Sort[sList]}


(* ::Input::Initialization:: *)
ConvertToSpecialSubgroup[M_,{N_,sList_List},w_String]:=StringReplace[w,Table[sList[[i]]->ToString[i],{i,1,Length[sList]}]]
ConvertToSpecialSubgroup[M_,{N_,sList_List},wList_List]:=ConvertToSpecialSubgroup[M,{N,sList},#]&/@wList
(*Private function: ConvertToSpecialSubgroup[M,{N,sList},w] rewrites the word w which is an element of the special subgroup W(N) of W(M), which is expressed in the generators of W(M), as a word in the generators {\"1\",...,\"Length[N]\"} which have been identified with the slements of sList.
ConvertToSpecialSubgroup[M,{N,sList},wList] rewrites each element in wList in terms of the new generators of W(N).*)


(* ::Input::Initialization:: *)
ConvertFromSpecialSubgroup[M_,{N_,sList_List},w_String]:=StringReplace[w,Table[ToString[i]-> sList[[i]],{i,1,Length[sList]}]]
ConvertFromSpecialSubgroup[M_,{N_,sList_List},wList_List]:=ConvertFromSpecialSubgroup[M,{N,sList},#]&/@wList
(*Private function: ConvertFromSpecialSubgroup[M,{N,sList},w] applies the inverse operation to ConvertToSpecialSubgroup[M,{N,sList},w].
ConvertFromSpecialSubgroup[M,{N,sList},wList] applies the inverse operation to ConvertToSpecialSubgroup[M,{N,sList},wList].*)


(* ::Input::Initialization:: *)
IrreducibleFactorComplement[M_,s_]:=SpecialSubgroup[M,Complement[Generators[M],IrreducibleFactor[M,s]]]
(*Private function: IrreducibleFactorComplement[M,s] returns the list of all generators not contained in the irreducible factor containing the generator s.*)


(* ::Input::Initialization:: *)
IrreducibleFactors[M_]:=If[IrreducibleCGQ[M],{Generators[M]},
Join[{IrreducibleFactor[M,"1"]},
ConvertFromSpecialSubgroup[M,IrreducibleFactorComplement[M,"1"],#
]&/@IrreducibleFactors[IrreducibleFactorComplement[M,"1"][[1]]]
]
]


(* ::Input::Initialization:: *)
IrreducibleSpecialSubgroups[M_]:=SpecialSubgroup[M,#]&/@IrreducibleFactors[M]


SpecialSubgroups[M_]:=SpecialSubgroup[M,#]&/@Drop[Subsets[Generators[M]],1]


SphericalSubgroups[M_]:=Select[SpecialSubgroups[M],SphericalCGQ[#[[1]]]&]


EuclideanCGQ[args___]:=(Message[EuclideanCGQ::argerr];$Failed)
SphericalCGQ[args___]:=(Message[SphericalCGQ::argerr];$Failed)
HyperbolicCGQ[args___]:=(Message[HyperbolicCGQ::argerr];$Failed)
EvenCGQ[args___]:=(Message[EvenCGQ::argerr];$Failed)
RACGQ[args___]:=(Message[RACGQ::argerr];$Failed)


EuclideanCGQ[M_]:=FormSignature[N[BilinearForm[M]]]=={Length[M]-1,1,0}/;IrreducibleCGQ[M]
EuclideanCGQ[M_]:=Fold[And,EuclideanCGQ[#[[1]]]&/@IrreducibleSpecialSubgroups[M]]/;!IrreducibleCGQ[M]


SphericalCGQ[M_]:=FormSignature[N[BilinearForm[M]]]=={Length[M],0,0}


HyperbolicCGQ[M_]:=FormSignature[N[BilinearForm[M]]]=={Length[M]-1,0,1}


EvenCGQ[M_]:=Fold[And,Or[EvenQ[#],MemberQ[{1,Infinity},#]]&/@DeleteDuplicates[Flatten[M]]]


RACGQ[M_]:=Fold[And,MemberQ[{1,2,Infinity},#]&/@DeleteDuplicates[Flatten[M]]]


GroupSize[args___]:=(Message[GroupSize::argerr];$Failed)
MaxLength[args___]:=(Message[MaxLength::argerr];$Failed)
CoxeterNumber[args___]:=(Message[CoxeterNumber::argerr];$Failed)
DavisComplexDimension[args___]:=(Message[DavisComplexDimension::argerr];$Failed)


GroupSize[M_]:=51840/;M==E6
GroupSize[M_]:=2903040/;M==E7
GroupSize[M_]:=696729600/;M==E8
GroupSize[M_]:=1152/;M==F4
GroupSize[M_]:=12/;M==G2
GroupSize[M_]:=120/;M==H3
GroupSize[M_]:=14400/;M==H4
GroupSize[M_]:=Module[{n},
n=Length[M];
If[n==2,2M[[1]][[2]],
If[M==TypeA[n],Factorial[n+1],
If[M==TypeB[n],2^n Factorial[n],
If[M==TypeD[n],2^(n-1)Factorial[n],Infinity]]]]
]/;IrreducibleCGQ[M]&&!MemberQ[{E6,E7,E8,F4,G2,H3,H4},M]
GroupSize[M_]:=Fold[Times,GroupSize[#[[1]]]&/@IrreducibleSpecialSubgroups[M]]/;!IrreducibleCGQ[M]


MaxLength[M_]:=36/;M==E6
MaxLength[M_]:=63/;M==E7
MaxLength[M_]:=120/;M==E8
MaxLength[M_]:=24/;M==F4
MaxLength[M_]:=6/;M==G2
MaxLength[M_]:=15/;M==H3
MaxLength[M_]:=60/;M==H4
MaxLength[M_]:=Module[{n},
n=Length[M];
If[n==2,M[[1]][[2]],
If[M==TypeA[n],Binomial[n+1,2],
If[M==TypeB[n],n^2,
If[M==TypeD[n],n^2-n,Infinity]]]]]/;IrreducibleCGQ[M]&&!MemberQ[{E6,E7,E8,F4,G2,H3,H4},M]
MaxLength[M_]:=Total[MaxLength[#[[1]]]&/@IrreducibleSpecialSubgroups[M]]/;!IrreducibleCGQ[M]


CoxeterNumber[M_]:=12/;M==E6
CoxeterNumber[M_]:=18/;M==E7
CoxeterNumber[M_]:=30/;M==E8
CoxeterNumber[M_]:=12/;M==F4
CoxeterNumber[M_]:=6/;M==G2
CoxeterNumber[M_]:=10/;M==H3
CoxeterNumber[M_]:=30/;M==H4
CoxeterNumber[M_]:=Module[{n},
n=Length[M];
If[n==2,M[[1]][[2]],
If[M==TypeA[n],n+1,
If[M==TypeB[n],2n,
If[M==TypeD[n],2n-1,Infinity]]]]]/;IrreducibleCGQ[M]&&!MemberQ[{E6,E7,E8,F4,G2,H3,H4},M]
CoxeterNumber[M_]:=Fold[LCM,CoxeterNumber[#[[1]]]&/@IrreducibleSpecialSubgroups[M]]/;!IrreducibleCGQ[M]


DavisComplexDimension[M_]:=Max[Length[#[[1]]]&/@SphericalSubgroups[M]]


StringCharacters[args___]:=(Message[StringCharacters::argerr];$Failed)
ValidCharacters[args___]:=(Message[ValidCharacters::argerr];$Failed)
ValidFileNameQ[args___]:=(Message[ValidFileNameQ::argerr];$Failed)
NamedQ[args___]:=(Message[NamedQ::argerr];$Failed)
ElementDirName[args___]:=(Message[ElementDirName::argerr];$Failed)
ElementDirExistQ[args___]:=(Message[ElementDirExistQ::argerr];$Failed)
CreateElementDir[args___]:=(Message[CreateElementDir::argerr];$Failed)
ExportElementList[args___]:=(Message[ExportElementList::argerr];$Failed)
LengthEnumerated[args___]:=(Message[LengthEnumerated::argerr];$Failed)
EnumeratedQ[args___]:=(Message[EnumeratedQ::argerr];$Failed)
SmoothDirName[args___]:=(Message[SmoothDirName::argerr];$Failed)
SmoothDirExistQ[args___]:=(Message[SmoothDirExistQ::argerr];$Failed)
CreateSmoothDir[args___]:=(Message[CreateSmoothDir::argerr];$Failed)
ExportSmoothList[args___]:=(Message[ExportSmoothList::argerr];$Failed)
SmoothEnumeratedQ[args___]:=(Message[SmoothEnumeratedQ::argerr];$Failed)


StringCharacters[name_]:=DeleteDuplicates[Table[StringTake[name,{i}],{i,1,StringLength[name]}]]


ValidCharacters[]:={"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","B","O","P","Q","R","S","T","U","V","W","X","Y","Z","0","1","2","3","4","5","6","7","8","9"," ","-","_",",",".","(",")"}


ValidFileNameQ[name_]:=If[SubsetQ[ValidCharacters[],StringCharacters[name]],True,
Module[{},
Message[GroupName::invalidGroupName];
False
]
]


NamedQ[M_]:=If[StringQ[GroupName[M]],True,
Module[{},
Message[GroupName::undefined,M];
False
]
]


ElementDirName[M_]:=FileNameJoin[{$UserBaseDirectory,"Applications","CoxeterGroups","GroupData","GroupElements",GroupName[M]}]/;NamedQ[M]&&ValidFileNameQ[GroupName[M]]


ElementDirExistQ[M_]:=DirectoryQ[ElementDirName[M]]


CreateElementDir[M_]:=CreateDirectory[ElementDirName[M]]


ExportElementList[M_,{k_},wordList_]:=Module[{},
If[Not[ElementDirExistQ[M]],CreateElementDir[M],Null];
Export[FileNameJoin[{ElementDirName[M],"0.mx"}],{""}];
Export[FileNameJoin[{ElementDirName[M],"1.mx"}],Generators[M]];
Export[FileNameJoin[{ElementDirName[M],"2.mx"}],wordList]
]/;k==2
ExportElementList[M_,{k_},wordList_]:=
Export[FileNameJoin[{ElementDirName[M],ToString[k]<>".mx"}],wordList]/;k>=3


LengthEnumerated[M_]:=If[
NamedQ[M],
If[
ElementDirExistQ[M],
Max[ToExpression[StringDrop[FileNameTake[#,-1],-3]]&/@FileNames[All,ElementDirName[M]]],
-1
],
-1
]


EnumeratedQ[M_,k_]:=k<=LengthEnumerated[M]


SmoothDirName[M_]:=FileNameJoin[{$UserBaseDirectory,"Applications","CoxeterGroups","GroupData","SmoothElements",GroupName[M]}]/;NamedQ[M]&&ValidFileNameQ[GroupName[M]]


SmoothDirExistQ[M_]:=DirectoryQ[SmoothDirName[M]]


CreateSmoothDir[M_]:=CreateDirectory[SmoothDirName[M]]


ExportSmoothList[M_,{k_},wordList_]:=Module[{},
If[Not[SmoothDirExistQ[M]],CreateSmoothDir[M],Null];
Export[FileNameJoin[{SmoothDirName[M],ToString[k]<>".mx"}],wordList]
]


SmoothEnumeratedQ[M_,{k_}]:=FileExistsQ[FileNameJoin[{SmoothDirName[M],ToString[k]<>".mx"}]]


TypeA[args___]:=(Message[TypeA::argerr];$Failed)
TypeB[args___]:=(Message[TypeB::argerr];$Failed)
TypeC[args___]:=(Message[TypeC::argerr];$Failed)
TypeD[args___]:=(Message[TypeD::argerr];$Failed)
I2[args___]:=(Message[I2::argerr];$Failed)
TypeAE[args___]:=(Message[TypeAE::argerr];$Failed)
TypeAE[args___]:=(Message[TypeBE::argerr];$Failed)
TypeAE[args___]:=(Message[TypeCE::argerr];$Failed)
TypeAE[args___]:=(Message[TypeDE::argerr];$Failed)
TriangleCG[args___]:=(Message[TriangleCG::argerr];$Failed)
FreeCG[args___]:=(Message[FreeCG::argerr];$Failed)
RAPolygonG[args___]:=(Message[RAPolygonG::argerr];$Failed)
RABipartiteG[args___]:=(Message[RABipartiteG::argerr];$Failed)
RACGroup[args___]:=(Message[RACGroup::argerr];$Failed)
RACGroup[arg_]:=(Message[RACGroup::argtype];$Failed)


SymmetricEntry[i_,j_]:=If[i==j,1,If[Abs[i-j]==1,3,2]]


TypeA[n_]:=Table[SymmetricEntry[i,j],{i,1,n},{j,1,n}]
GroupName[M_]:="A_"<>ToString[Length[M]]/;M==TypeA[Length[M]]


TypeB[n_]:=Table[If[Or[i==n&&j==n-1,i==n-1&&j==n],4,SymmetricEntry[i,j]],{i,1,n},{j,1,n}]
GroupName[M_]:="B_"<>ToString[Length[M]]/;M==TypeB[Length[M]]


TypeC[n_]:=TypeB[n]


TypeD[n_]:=Table[If[Or[i==n&&j==n-2,i==n-2&&j==n],3,If[Or[i==n&&j==n-1,i==n-1&&j==n],2,SymmetricEntry[i,j]]],{i,1,n},{j,1,n}]
GroupName[M_]:="D_"<>ToString[Length[M]]/;M==TypeD[Length[M]]


E6={{1,3,2,2,2,2},{3,1,3,2,2,2},{2,3,1,3,2,3},{2,2,3,1,3,2},{2,2,2,3,1,2},{2,2,3,2,2,1}};
GroupName[E6]="E_6";


E7={{1,3,2,2,2,2,2},{3,1,3,2,2,2,2},{2,3,1,3,2,2,3},{2,2,3,1,3,2,2},{2,2,2,3,1,3,2},{2,2,2,2,3,1,2},{2,2,3,2,2,2,1}};
GroupName[E7]="E_7";


E8={{1,3,2,2,2,2,2,2},{3,1,3,2,2,2,2,2},{2,3,1,3,2,2,2,3},{2,2,3,1,3,2,2,2},{2,2,2,3,1,3,2,2},{2,2,2,2,3,1,3,2},{2,2,2,2,2,3,1,2},{2,2,3,2,2,2,2,1}};
GroupName[E8]="E_8";


F4={{1,3,2,2},{3,1,4,2},{2,4,1,3},{2,2,3,1}};


G2={{1,6},{6,1}};
GroupName[F4]="F_4";


H3={{1,3,2},{3,1,5},{2,5,1}};
GroupName[H3]="H_3";


H4={{1,3,2,2},{3,1,3,2},{2,3,1,5},{2,2,5,1}};
GroupName[H4]="H_4";


I2[m_]:={{1,m},{m,1}}
GroupName[M_]:="I_2("<>ToString[M[[1]][[2]]]<>")"/;Length[M]==2&&!MemberQ[{I2[3],I2[4],I2[6]},M]&&ValidCoxeterMatrixQ[M]


TypeAE[1]={{1,Infinity},{Infinity,1}};
TypeAE[n_]:=TypeA[n+1]+Table[Table[If[Or[And[i==1,j==n+1],And[i==n+1,j==1]],1,0],{i,1,n+1}],{j,1,n+1}]/;n>1
GroupName[M_]:="AE_"<>ToString[Length[M]-1]/;M==TypeAE[Length[M]-1]


TypeBE[2]={{1,4,2},{4,1,4},{2,4,1}};
GroupName[TypeBE[2]]="BE_2";


TypeBE[n_]:=Table[If[And[i<n+1,j<n+1],TypeB[n][[i]][[j]],If[And[i==n+1,j==n+1],1,If[Or[i==2,j==2],3,2]]],{i,1,n+1},{j,1,n+1}]/;n>2
GroupName[M_]:="BE_"<>ToString[Length[M]-1]/;M==TypeBE[Length[M]-1]


TypeCE[n_]:=TypeB[n+1]+Table[If[Or[And[i==1,j==2],And[i==2,j==1]],1,0],{i,1,n+1},{j,1,n+1}]/;n>2
GroupName[M_]:="CE_"<>ToString[Length[M]-1]/;M==TypeCE[Length[M]-1]


TypeDE[n_]:=TypeD[n+1]+Table[If[Or[And[i==1,j==2],And[i==2,j==1]],-1,If[Or[And[i==1,j==3],And[i==3,j==1]],1,0]],{i,1,n+1},{j,1,n+1}]/;n>3
GroupName[M_]:="DE_"<>ToString[Length[M]-1]/;M==TypeDE[Length[M]-1]


EE6=Table[If[And[i<7,j<7],E6[[i]][[j]],If[Or[And[i==7,j==7]],1,If[Or[i==6,j==6],3,2]]],{i,1,7},{j,1,7}];
GroupName[EE6]="EE_6";


EE7={{1,3,2,2,2,2,2,2},{3,1,3,2,2,2,2,2},{2,3,1,3,2,2,2,2},{2,2,3,1,3,2,2,3},{2,2,2,3,1,3,2,2},{2,2,2,2,3,1,3,2},{2,2,2,2,2,3,1,2},{2,2,2,3,2,2,2,1}};
GroupName[EE7]="EE_7";


EE8={{1,3,2,2,2,2,2,2,2},{3,1,3,2,2,2,2,2,2},{2,3,1,3,2,2,2,2,3},{2,2,3,1,3,2,2,2,2},{2,2,2,3,1,3,2,2,2},{2,2,2,2,3,1,3,2,2},{2,2,2,2,2,3,1,3,2},{2,2,2,2,2,2,3,1,2},{2,2,3,2,2,2,2,2,1}};
GroupName[EE8]="EE_8";


FE4={{1,3,2,2,2},{3,1,3,2,2},{2,3,1,4,2},{2,2,4,1,3},{2,2,2,3,1}};
GroupName[FE4]="FE_4";


GE2={{1,3,2},{3,1,6},{2,6,1}};
GroupName[GE2]="GE_2";


TriangleCG[p_,q_,r_]:={{1,p,r},{p,1,q},{r,q,1}};
GroupName[M_]:="TriangleCG("<>ToString[M[[1]][[2]]]<>","<>ToString[M[[1]][[3]]]<>","<>ToString[M[[2]][[3]]]<>")"/;Length[M]==3&&HyperbolicCGQ[M]&&ValidCoxeterMatrixQ[M]


FreeCG[n_]:=Table[Table[
If[i==j,1,Infinity],
{i,1,n}],
{j,1,n}]
GroupName[M_]:="FreeCG_"<>ToString[Length[M]]/;M==FreeCG[Length[M]]&&Length[M]>1


RAPolygonG[n_]:=Table[
Permute[
Join[{1,2},Table[Infinity,{i,1,n-3}],{2}],
PermutationPower[Cycles[{Table[k,{k,1,n}]}],j-1]],
{j,1,n}]
GroupName[M_]:="RAPolygonG_"<>ToString[Length[M]]/;M==RAPolygonG[Length[M]]&&Length[M]>=4


RABipartiteG[m_,n_]:=Table[Table[
If[i==j,1,If[(i<=n&&j<=n)||(i>n&&j>n),Infinity,2]],
{i,1,n+m}],
{j,1,n+m}]
GroupName[M_]:=Module[{m,n},
n=Length[Select[M[[1]],#==2&]];
m=Length[M]-n;
"RABipartiteG_("<>ToString[n]<>","<>ToString[m]<>")"/;M==RABipartiteG[n,m]&&Length[M]>3
]


(* ::Input::Initialization:: *)
RACGroup[A_]:=Table[Table[If[i==j,1,If[A[[i]][[j]]==1,2,Infinity]],{i,1,Length[A]}],{j,1,Length[A]}]/;MatrixQ[A]&&SubsetQ[{0,1},Flatten[A]]&&SymmetricMatrixQ[A]


End[];


Protect[(*Coxeter matrix and Coxeter form*)
ValidCoxeterMatrixQ,BilinearForm, FormSignature,
(*Special Subgroups*)
Generators, DiagramNeighbours,ConnectedComponentUnionQ,IrreducibleFactor,IrreducibleCGQ,SpecialSubgroup,ConvertToSpecialSubgroup,ConvertFromSpecialSubgroup,IrreducibleFactorComplement,IrreducibleFactors,IrreducibleSpecialSubgroups,SpecialSubgroups,SphericalSubgroups,
(*Types of Coxeter system*)
EuclideanCGQ, SphericalCGQ,HyperbolicCGQ,EvenCGQ,RACGQ,
(*Coxeter system data*)
GroupSize,MaxLength,CoxeterNumber,DavisComplexDimension,
(*Group element storage*)
StringCharacters, ValidCharacters, ValidFileNameQ,NamedQ,ElementDirName, ElementDirExistQ,CreateElementDir,ExportElementList,LengthEnumerated,EnumeratedQ,SmoothDirName, SmoothDirExistQ,CreateSmoothDir,ExportSmoothList,SmoothEnumeratedQ,
(*Examples of Coxeter matrices*)
SymmetricEntry,TypeA,TypeB,TypeC,TypeD,E6,E7,E8,F4,G2,H3,H4,I2,TypeAE,TypeAE,TypeAE,TypeAE,EE6,EE7,EE8,FE4,GE2,TriangleCG,FreeCG,RAPolygonG,RABipartiteG,RACGroup
];


EndPackage[];
