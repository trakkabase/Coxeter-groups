(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: CoxeterCombinatorics *) 
(* :Author: David Sheard *)
(* :Summary: Functions relating to the combinatorial group theory of Coxeter systems. *)
(* :Context: CoxeterGroups`CoxeterCombinatorics` *)
(* :Package version: 1.0 *)
(* :History:  Version 1.0 February 28 2022 *)
(* :Mathematica version: 12.0.0 for Microsoft Windows (64-bit) (April 6, 2019) *)
(* :Discussion: Give more details here.*)


BeginPackage[
"CoxeterGroups`CoxeterCombinatorics`",
{"CoxeterGroups`BasicCoxeterFunctions`","CoxeterGroups`ElementEnumeration`"}
];


Unprotect[
(*Inversions*)
Inversions,DescentSet,CentralGenerator,ConjugatingElement,
(*Strong Bruhat order*)
StrongBruhatCover,StrongBruhatGraph,StrongBruhatIdeal
];
ClearAll[
(*Inversions*)
Inversions,DescentSet,CentralGenerator,ConjugatingElement,
(*Strong Bruhat order*)
StrongBruhatCover,StrongBruhatGraph,StrongBruhatIdeal
];


Inversions::usage="Inversions[M, w,\"left\"] lists all reflections in the Coxeter system associated to M which reduce the length of w when multiplied on the left.\[IndentingNewLine]Inversions[M, w,\"right\"] lists all reflections in the Coxeter system associated to M which reduce the length of w when multiplied on the right.";
DescentSet::usage="DescentSet[M, w, \"left\"] lists all simple reflenctions in the Coxeter system associated to M which reduce the length of w when multiplied on the left.
DescentSet[M, w, \"right\"] lists all simple reflenctions in the Coxeter system associated to M which reduce the length of w when multiplied on the right.";
CentralGenerator::usage="CentralGenerator[\"word\"] returns the middle s-symbol in \"word\" if it is palindromic and represents a reflection.";
ConjugatingElement::usage="CentralGenerator[\"word\"] returns the subword of \"word\" such that \"word\" is the conjugate of some generator by that subword.";


BruhatGraph::usage="BruhatGraph[M, wList] gives the directed graph whose vertices are the elements of the Coxeter system associated to M listed in wList, and whose directed edges join elements whose length differes by 1, and which are related by Bruhat order.";


Inversions::argerr="Three arguments expected.";
Inversions::handedness="The third argument must be \"left\" or \"right\"";
DescentSet::argerr="Three arguments expected.";
DescentSet::handedness="The third argument must be \"left\" or \"right\"";
CentralGenerator::argerr="One string argument expected.";
CentralGenerator::notpalindromic="The input must be a palindromic word.";
ConjugatingElement::argerr="One string argument expected.";
ConjugatingElement::notpalindromic="The input must be a palindromic word.";


BruhatGraph::argerr="Two arguments expected.";


Begin["`Private`"];


Inversions[args___]:=(Message[Inversions::argerr];$Failed)
Inversions[M_,w_,side_]:=(Message[Inversions::handedness];$Failed)/;!MemberQ[{"left","right"},side]
DescentSet[args___]:=(Message[DescentSet::argerr];$Failed)
DescentSet[M_,w_,side_]:=(Message[DescentSet::handedness];$Failed)/;!MemberQ[{"left","right"},side]
CentralGenerator[args___]:=(Message[CentralGenerator::argerr];$Failed)
ConjugatingElement[args___]:=(Message[ConjugatingElement::argerr];$Failed)


(* ::Input::Initialization:: *)
MakePalindromic[u_String]:=If[
WordLength[u]==1,
u,
StringJoin[u,WordDrop[WordInverse[u],1]]
]


(* ::Input::Initialization:: *)
Inversions[M_,w_String,"left"]:=Table[
Select[
CoxeterReduce[M,MakePalindromic[WordTake[FindCoxeterReducedWord[M,w],k]]],
WordPalindromeQ[#]&,1
][[1]],
{k,1,CoxeterLength[M,w]}
]
Inversions[M_,w_String,"right"]:=Inversions[M,WordInverse[w],"left"]


(* ::Input::Initialization:: *)
CentralGenerator[w_String]:=WordTake[w,{(WordLength[w]+1)/2}]/;WordPalindromeQ[w]&&OddQ[WordLength[w]]
CentralGenerator[w_]:=(Message[CentralGenerator::notpalindromic];$Failed)/;!WordPalindromeQ[w]||!OddQ[WordLength[w]]


(* ::Input::Initialization:: *)
ConjugatingElement[w_String]:=WordTake[w,(WordLength[w]-1)/2]/;WordPalindromeQ[w]&&OddQ[WordLength[w]]
ConjugatingElement[w_]:=(Message[ConjugatingElement::notpalindromic];$Failed)/;!WordPalindromeQ[w]||!OddQ[WordLength[w]]


DescentSet[M_,w_,"left"]:=Select[
Generators[M],ReducibleWordQ[M,StringJoin[#,FindCoxeterReducedWord[M,w]]]&
]
DescentSet[M_,w_,"right"]:=DescentSet[M,WordInverse[w],"left"]


StrongBruhatCover[M_,w_]:=Graph[Labeled[CoxeterMultiply[M,#,w]->w,#]&/@Inversions[M,w,"left"]]


StrongBruhatGraph[M_,wList_List]:=Fold[GraphUnion,StrongBruhatCover[M,#]&/@wList]


StrongBruhatGraph[M_,k_Integer]:=StrongBruhatGraph[M,CoxeterGroupElements[M,k]]


StrongBruhatIdeal[M_,""]:=Graph[{""},{}]
StrongBruhatIdeal[M_,w_]:=Graph[{""->w}]/;GeneratorQ[w]
StrongBruhatIdeal[M_,w_]:=If[
StringMatchQ[w,"s"~~x__~~"s"~~x__/;!StringContainsQ[x,"s"]],
StrongBruhatIdeal[M,""],
Graph[Join[{""},WordSymbols[w]],Flatten[{""->#,#->w}&/@WordSymbols[w]]]
]/;WordLength[w]==2
StrongBruhatIdeal[M_,w_]:=Module[{cover,lower},
cover=StrongBruhatCover[M,w];
lower=Fold[GraphUnion,StrongBruhatIdeal[M,#]&/@Complement[VertexList[cover],{w}]];
GraphUnion[cover,lower]
]


SubWords[M_,"",k_]:={}
SubWords[M_,w_,k_]:=DeleteDuplicates[FindCoxeterReducedWord[M,Fold[StringJoin,#]]&/@Subsets[WordToList[w],{k}]]


CoxeterReducedSubWords[M_,w_,k_]:=Sort[DeleteDuplicates[Select[SubWords[M,w,k],Not[nonMinimalQ[M,#]]&]]]


titBruhatLess[M_,""]:={}
titBruhatLess[M_,w_]:=Module[{x,d,r},
x=FindCoxeterReducedWord[M,w];
d=WordLength[x];
r=CoxeterReducedSubWords[M,x,d-1];
titBruhatLess[M,w]={#,x}&/@r
]


titBruhatLessList[M_,""]:={};
titBruhatLessList[M_,w_]:=
titBruhatLessList[M,w]=#[[1]]&/@titBruhatLess[M,w]


titBruhatGraph[M_,""]:=Graph[{""},{}]
titBruhatGraph[M_,w_]:=Graph[{""->w}]/;GeneratorQ[w]
titBruhatGraph[M_,w_]:=
DeleteDuplicates[Join[titBruhatLess[M,w],Fold[Join,titBruhatGraph[M,#]&/@titBruhatLessList[M,w]]]]


(*To be carefully re-written*)


WeakBruhatCover[M_,w_]:=Graph[Labeled[CoxeterMultiply[M,w,#]->w,#]&/@DescentSet[M,w,"right"]]


WeakBruhatGraph[M_,wList_List]:=Fold[GraphUnion,WeakBruhatCover[M,#]&/@wList]


WeakBruhatGraph[M_,k_Integer]:=BruhatGraph[M,CoxeterGroupElements[M,k]]


GalleryLeftBruhatIdeal[M_,w_]:=Show[ShowLeftBruhatIdeal[M,w,GrayLevel[0.9]],Gallery[M,w]]


GalleryLengthIdeal[M_,w_String]:=Show[ShowLengthIdeal[M,CoxeterLength[M,w],GrayLevel[0.9]],Gallery[M,w]]
GalleryLengthIdeal[M_,wList_List]:=Show[ShowLengthIdeal[M,Max[CoxeterLength[M,#]&/@wList],GrayLevel[0.9]],Gallery[M,wList]]


End[];


Protect[
(*Inversions*)
Inversions,DescentSet,CentralGenerator,ConjugatingElement,
(*Strong Bruhat order*)
StrongBruhatCover,StrongBruhatGraph,StrongBruhatIdeal
];


EndPackage[];
