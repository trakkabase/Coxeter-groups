(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: CoxeterVisualisation *) 
(* :Author: David Sheard *)
(* :Summary: Functions to visualise various aspects of Coxeter systems. *)
(* :Context: CoxeterGroups`CoxeterVisualisation` *)
(* :Package version: 1.0 *)
(* :History:  Version 1.0 February 28 2022 *)
(* :Mathematica version: 12.0.0 for Microsoft Windows (64-bit) (April 6, 2019) *)
(* :Discussion: Give more details here.*)


BeginPackage["CoxeterGroups`CoxeterVisualisation`",{"CoxeterGroups`BasicCoxeterFunctions`"}];


Unprotect[ShowChambers,ShowHyperplanes,ShowGalleries];
ClearAll[ShowChambers,ShowHyperplanes,ShowGalleries];


(*Unprotect[
(*Visualisabel*)
VisualisableQ,VisualisationDimension,
(*Euclidean geometry*)
EuclideanPoints,EuclideanReflection,EuclideanLineSegments,EuclideanPolygon,NormalVector,EuclideanReflection,EuclideanPolyhedron,
(*Spherical geometry*)
Bearing,SphericalArc,SphericalReflection,CircularArc3D,Circle3D,SphericalPolygon,SphericalReflection,
(*Hyperbolic geometry*)
(*Transformations*)
PointsToEdges,ChamberWalls,WallGeneratorPairs,Transformation,
(*Chambers*)
ChamberVertices,Chamber,ChamberBarycentre,ShowChambers,
(*Hyperplanes*)
ZeroVector,BasePoint,CoxeterHyperplane,ShowHyperplanes,
(*Galleries*)
Gallery,ShowGalleries
];
ClearAll[
(*Visualisabel*)
VisualisableQ,VisualisationDimension,
(*Euclidean geometry*)
EuclideanPoints,EuclideanReflection,EuclideanLineSegments,EuclideanPolygon,NormalVector,EuclideanReflection,EuclideanPolyhedron,
(*Spherical geometry*)
Bearing,SphericalArc,SphericalReflection,CircularArc3D,Circle3D,SphericalPolygon,SphericalReflection,
(*Hyperbolic geometry*)
(*Transformations*)
PointsToEdges,ChamberWalls,WallGeneratorPairs,Transformation,
(*Chambers*)
ChamberVertices,Chamber,ChamberBarycentre,ShowChambers,
(*Hyperplanes*)
ZeroVector,BasePoint,CoxeterHyperplane,ShowHyperplanes,
(*Galleries*)
Gallery,ShowGalleries
];*)


ShowChambers::usage="ShowChambers[M, {w1, w2, ...}, options] renders the chambers in the Coxeter complex of the Coxeter system associated to M which are labelled by the elements w1, w2, etc.";
ShowHyperplanes::usage="ShowHyperplanes[M, {r1, r2, ...}, options] renders the reflection hyperplanes in the Coxeter complex of the Coxeter system associated to M which are labelled by the reflections r1, r2, etc.";
ShowGalleries::usage="ShowGalleries[M, {w1, w2, ...}, options] illestrates the galleries in the Coxeter complex of the Coxeter system associated to M which are labelled by the words w1, w2, etc.";


ShowChambers::argerr="Two inputs expected, plus options.";
ShowHyperplanes::argerr="Two inputs expected, plus options.";
ShowGalleries::argerr="Two inputs expected, plus options.";
ShowChambers::visualisation="Not possible to visualise chambers in the Coxeter system of this type.";
ShowHyperplanes::visualisation="Not possible to visualise hyperplanes in the Coxeter system of this type.";
ShowGalleries::visualisation="Not possible to visualise galleries in the Coxeter system of this type.";
ShowGalleries::empty="There is no gallery associated to the trivial word.";


Begin["`Private`"];


VisualisableQ[M_]:=(SphericalCGQ[M]&&2<=Length[M]<=3)||(EuclideanCGQ[M]&&DavisComplexDimension[M]<=3)(*||(HyperbolicCGQ[M]&&DavisComplexDimension[M]\[Equal]2)||(I2[m]xI2[n])||(I2[m]xAE[1])*)


VisualisationDimension[M_]:=Length[M]/;SphericalCGQ[M]&&VisualisableQ[M]
VisualisationDimension[M_]:=Max[DavisComplexDimension[M],2]/;EuclideanCGQ[M]&&VisualisableQ[M]
VisualisationDimension[M_]:=2/;HyperbolicCGQ[M]&&VisualisableQ[M]


(* ::Input::Initialization:: *)
EuclideanPoints[vertexList_List]:=Point[Join[#,{0}]&/@vertexList]


(* ::Input::Initialization:: *)
EuclideanReflection[{{x_}},{a_}]:={x-(a-x)}


(* ::Input::Initialization:: *)
EuclideanLineSegments[vertexList_List,outlined_,outlineColour_,pointSize_,colour_,thickness_]:=
Graphics[
Join[
{colour,thickness,Line[{#[[1]],0}&/@vertexList]},
If[outlined,{outlineColour,PointSize[pointSize], EuclideanPoints[vertexList]},{}]]
]


(* ::Input::Initialization:: *)
EuclideanPolygon[vertexList_List, outlined_,outlineColour_,outlineThickness_,colour_]:=Graphics[{
colour,
If[
outlined,
EdgeForm[{outlineColour,outlineThickness}],
EdgeForm[]
],
Polygon[vertexList]
}]


(* ::Input::Initialization:: *)
NormalVector[{{x1_,y1_},{x2_,y2_}}]:=RotationTransform[Pi/2][{x1-x2,y1-y2}]


(* ::Input::Initialization:: *)
EuclideanReflection[{p1_,p2_},a_]:=ReflectionTransform[N[NormalVector[{p1,p2}]],N[p1]][N[a]]


(* ::Input::Initialization:: *)
NormalVector[{{x1_,y1_,z1_},{x2_,y2_,z2_},{x3_,y3_,z3_}}]:=Cross[{x1,y1,z1}-{x2,y2,z2},{x1,y1,z1}-{x3,y3,z3}]


(* ::Input::Initialization:: *)
EuclideanPolyhedron[vertexList_List,colour_,opacity_]:=ConvexHullMesh[vertexList,MeshCellStyle-> {colour,Opacity[opacity]}]


(* ::Input::Initialization:: *)
EuclideanReflection[{p1_,p2_,p3_},a_]:=ReflectionTransform[N[NormalVector[{p1,p2,p3}]],N[p1]][N[a]]


(* ::Input::Initialization:: *)
Bearing[{{xc_,yc_},{x1_,y1_}}]:=Arg[(x1-xc)+I(y1-yc)]
Bearing[{normal_,{x1_,y1_,z1_}}]:=Bearing[{{0,0},Take[RotationTransform[{normal,{0,0,1}},{0,0,0}][{x1,y1,z1}],2]}]


(* ::Input::Initialization:: *)
SphericalArc[{p1_,p2_},colour_:Gray]:=Graphics[{{Black,PointSize[Medium],Point[{p1,p2}]},{colour,Circle[{0,0},1,Bearing[{{0,0},#}]&/@{p1,p2}]}}]


(* ::Input::Initialization:: *)
SphericalReflection[{p_},a_]:=EuclideanReflection[{p,-p},a]


CircularArc3D[centre_,point1_,point2_,r_:1,colour_,thickness_]:=Module[{normal,point3,radius,angle},
normal=Normalize[Cross[point1-centre,point2-centre]];
point3=Cross[normal,Normalize[point1]];
radius=Norm[point1-centre];
angle=ArcCos[Dot[point1,point2]/radius^2];
ParametricPlot3D[
centre+r Cos[t]Normalize[point1]+r Sin[t]point3,
{t,0,angle},
Axes->False,
Boxed->False,
PlotStyle->Directive[colour,thickness]
]
]


Circle3D[centre_,point1_,point2_,r_,colour_,thickness_]:=Module[{normal,point3},
normal=Normalize[Cross[point1-centre,point2-centre]];
point3=Cross[normal,Normalize[point1]];
ParametricPlot3D[
centre+r Cos[t]Normalize[point1]+r Sin[t]point3,
{t,0,2Pi},
Axes->False,
Boxed->False,
PlotStyle->Directive[ colour,thickness]
]
]
Circle3D[centre_,normal_,r_,colour_,thickness_]:=Module[{n,point0,point1,point2},
n=Normalize[N[normal]];
point0=If[n=={1,0,0},{0,1,0},{1,0,0}];
point1=Cross[n,point0];
point2=Cross[n,point1];
Circle3D[centre,point1,point2,r,colour,thickness]
]


PointsToEdges[vertexList_,"path"]:=Table[
{vertexList[[i]],vertexList[[i+1]]},
{i,Length[vertexList]-1}
]
PointsToEdges[vertexList_,"cycle"]:=Join[PointsToEdges[vertexList,"path"],{{vertexList[[Length[vertexList]]],vertexList[[1]]}}]


ListArcPlot3D[pointList_,radius_,type_,colour_,thickness_]:=Show[CircularArc3D[{0,0,0},#[[1]],#[[2]],radius,colour,thickness]&/@PointsToEdges[pointList,type]]


Options[SphericalPolygon]={
"Outlined"->True,
"OutlineColour"->Black,
"OutlineThickness"->Thin,
"Opacity"->1,
"Colour"-> Gray
};


SphericalPolygon[vertexList_List,centre_List: {0,0,0},radius:_?Positive:1,OptionsPattern[]]:=Show[
Graphics3D[
{Opacity[1],
Style[
{OptionValue["Colour"],Sphere[centre,radius]},
ClipPlanes->Table[
With[
{ord=If[
VectorAngle[Cross@@segment[[;;2]],segment[[3]]]<Pi/2.,
Identity,
Reverse
]},
InfinitePlane[#+centre&/@ord@Prepend[segment[[;;2]],{0,0,0}]]
],
{segment,Partition[#-centre&/@vertexList,3,1,{1,1}]}
]
]
},
Boxed->False],
If[
OptionValue["Outlined"],
ListArcPlot3D[vertexList,1,"cycle",OptionValue["OutlineColour"],OptionValue["OutlineThickness"]],
ListPointPlot3D[{},Boxed->False,Axes->False]
]
]


(*https://mathematica.stackexchange.com/questions/144167/fast-spherical-polygon*)


(* ::Input::Initialization:: *)
SphericalReflection[{p1_,p2_},a_]:=EuclideanReflection[{p1,p2,{0,0,0}},a]


(* ::Input::Initialization:: *)
ChamberWalls[M_]:=PointsToEdges[ChamberVertices[M,"",True],"cycle"]/;(VisualisationDimension[M]==2&&!SphericalCGQ[M])||VisualisationDimension[M]==3
ChamberWalls[M_]:={#}&/@ChamberVertices[M,"",True]/;VisualisationDimension[M]==2&&SphericalCGQ[M]


(* ::Input::Initialization:: *)
WallGeneratorPairs[M_]:=Association[Table[Generators[M][[i]]->ChamberWalls[M][[i]],{i,Length[M]}]]


(* ::Input::Initialization:: *)
Transformation[M_,"",point_]:=point
Transformation[M_,s_,point_]:=SphericalReflection[WallGeneratorPairs[M][[s]],point]/;GeneratorQ[s]&&SphericalCGQ[M]
Transformation[M_,s_,point_]:=EuclideanReflection[WallGeneratorPairs[M][[s]],point]/;GeneratorQ[s]&&EuclideanCGQ[M]
Transformation[M_,s_,point_]:=PoincareReflection[WallGeneratorPairs[M][[s]],point]/;GeneratorQ[s]&&HyperbolicCGQ[M]
Transformation[M_,w_,point_]:=Simplify[Transformation[M,WordTake[w,1],Transformation[M,WordDrop[w,1],point]]]


ShowChambers[args___]:=(Message[ShowChambers::argerr];$Failed)
ShowChambers[M_,wList_,options___]:=(Message[ShowChambers::visualisation];$Failed)/;!VisualisableQ[M]


ChamberVertices[M_,w_,outlined_]:=Transformation[M,w,#]&/@N[ChamberVertices[M,"",outlined]]


ChamberBarycentre[M_,w_]:=Normalize[Mean[ChamberVertices[M,w,True]]]/;SphericalCGQ[M]&&VisualisationDimension[M]==3
ChamberBarycentre[M_,w_]:=Mean[Append[ChamberVertices[M,w,True],{0,0}]]/;SphericalCGQ[M]&&VisualisationDimension[M]==2
ChamberBarycentre[M_,w_]:=Mean[ChamberVertices[M,w,True]]/;EuclideanCGQ[M]
ChamberBarycentre[M_,w_]:=Mean[ChamberVertices[M,w,True]]/;HyperbolicCGQ[M]


ChamberVertices[M_,"",False]:=Normalize[0.95#+0.05ChamberBarycentre[M,""]]&/@ChamberVertices[M,"",True]/;SphericalCGQ[M]
ChamberVertices[M_,"",False]:=0.9#+0.1ChamberBarycentre[M,""]&/@ChamberVertices[M,"",True]/;EuclideanCGQ[M]


Options[Chamber]={
"Outlined"->True,
"OutlineColour"->Black,
"OutlineThickness"->Thin,
"PointSize"->Medium,
"Colour"->Gray,
"Thickness"->Thick,
"Opacity"->.2,
"UnderlyingSphere"->False,
"UnderlyingSphereColour"->White(*,
"ChamberLabels"\[Rule]False,
"WallLabels"\[Rule]False*)
};


Chamber[M_,w_,OptionsPattern[]]:=
Graphics[
EuclideanLineSegments[
ChamberVertices[M,w,OptionValue["Outlined"]],
OptionValue["Outlined"],OptionValue["OutlineColour"],OptionValue["PointSize"],OptionValue["Colour"],OptionValue["Thickness"]
]
]/;M==TypeAE[1]
Chamber[M_,w_,OptionsPattern[]]:=Module[{angles,angles2,vertex},
angles=Arg[#[[1]]+I #[[2]]]&/@ChamberVertices[M,w,OptionValue["Outlined"]];
angles2=If[
angles[[1]]-angles[[2]]>Pi,
{angles[[1]]-2Pi,angles[[2]]},
If[
angles[[1]]-angles[[2]]<-Pi,
{angles[[1]]+2Pi,angles[[2]]},
angles
]
];
vertex=If[
OptionValue["Outlined"],
{0,0},
0.2ChamberBarycentre[M,w]
];
Graphics[{
OptionValue["Colour"],
If[
OptionValue["Outlined"],
EdgeForm[{OptionValue["OutlineColour"],OptionValue["OutlineThickness"]}],
EdgeForm[]
],
Disk[vertex,1,angles2]
}]
]/;VisualisationDimension[M]==2&&SphericalCGQ[M]


Chamber[M_,w_,OptionsPattern[]]:=
EuclideanPolygon[
ChamberVertices[M,w,OptionValue["Outlined"]],
OptionValue["Outlined"],
OptionValue["OutlineColour"],
OptionValue["OutlineThickness"],
OptionValue["Colour"]
]/;VisualisationDimension[M]==2&&EuclideanCGQ[M]
(*Chamber[M_,w_,OptionsPattern[]]:=PoincarePolygon[ChamberVertices[M,w,OptionValue["Outlined"]],colour]/;Length[ChamberVertices[M,w,OptionValue["Outlined"]][[1]]]\[Equal]2&&HyperbolicCGQ[M]*)
Chamber[M_,w_,OptionsPattern[]]:=
SphericalPolygon[
ChamberVertices[M,w,OptionValue["Outlined"]],
{0,0,0},
1,
"Outlined"->OptionValue["Outlined"],
"OutlineColour"->OptionValue["OutlineColour"],
"OutlineThickness"->OptionValue["OutlineThickness"],
"Colour"->OptionValue["Colour"]
]/;VisualisationDimension[M]==3&&SphericalCGQ[M]


Chamber[M_,w_,OptionsPattern[]]:=EuclideanPolyhedron[
ChamberVertices[M,w,OptionValue["Outlined"]],
OptionValue["Colour"],
OptionValue["Opacity"]
]/;VisualisationDimension[M]==3&&EuclideanCGQ[M]


ShowChambers[M_,wList_List,options___]:=Show[Chamber[M,#,options]&/@wList]


ChamberVertices[TypeAE[1],"",True]={{0},{1}};
ChamberWalls[TypeAE[1]]={#}&/@ChamberVertices[TypeAE[1],"",True];


ChamberVertices[M_,"",True]:={{0,1},Normalize[{Tan[Pi/M[[1]][[2]]],1}]}/;Length[M]==2&&!M[[1]][[2]]==Infinity&&!M[[1]][[2]]==2
ChamberVertices[I2[2],"",True]={{0,1},{1,0}};


ChamberVertices[TypeA[3],"",True]={{-(1/Sqrt[6]),-(1/Sqrt[2]),1/Sqrt[3]},{0,0,1},{-((2 Sqrt[2])/3),0,1/3}};


ChamberVertices[TypeB[3],"",True]={{-(1/Sqrt[2]),-(1/Sqrt[2]),0},{-(1/Sqrt[3]),-(1/Sqrt[3]),-(1/Sqrt[3])},{-1,0,0}};


ChamberVertices[H3,"",True]={{0.3090169943749474`,0.8090169943749473`,0.49999999999999994`},{0.5773502691896258`,0.5773502691896258`,0.5773502691896258`},{0.`,0.5257311121191336`,0.85065080835204`}};


ChamberVertices[TypeAE[2],"",True]={{0,0},{1/2,Sqrt[3]/2},{1,0}};


ChamberVertices[TypeBE[2],"",True]={{0,0},{1,1},{1,0}};


ChamberVertices[GE2,"",True]={{1/2,0},{0,Sqrt[3]/2},{0,0}};


ChamberVertices[RAPolygonG[4],"",True]={{0,0},{0,1},{1,1},{1,0}}
WallGeneratorPairs[RAPolygonG[4]]=Association[Table[Generators[RAPolygonG[4]][[i]]->ChamberWalls[RAPolygonG[4]][[i]],{i,4}]];


 


ShowHyperplanes[args___]:=(Message[ShowHyperplanes::argerr];$Failed)
ShowHyperplanes[M_,wList_,options___]:=(Message[ShowHyperplanes::visualisation];$Failed)/;!VisualisableQ[M]


ZeroVector[M_]:=
Table[0,{k,1,Length[M]}]/;SphericalCGQ[M]
ZeroVector[M_]:=
Table[0,{k,1,Length[M]-1}]/;EuclideanCGQ[M]&&!M==RAPolygonG[4]
ZeroVector[RAPolygonG[4]]={0,0};


NormalVector[M_,r_]:=Normalize[
Drop[
Cross[
{0,0,1},
Append[
WallGeneratorPairs[M][[r]][[1]],
0
]
],
-1]
]/;SphericalCGQ[M]&&VisualisationDimension[M]==2&&WordLength[r]==1
NormalVector[M_,r_]:=Normalize[Fold[Cross,WallGeneratorPairs[M][[r]]]]/;SphericalCGQ[M]&&VisualisationDimension[M]==3&&WordLength[r]==1
NormalVector[M_,r_]:=
Normalize[
Drop[
Cross[
{0,0,1},
Append[
Fold[Subtract,WallGeneratorPairs[M][[r]]],
0
]
],
-1]
]/;WordLength[r]==1&&EuclideanCGQ[M]&&VisualisationDimension[M]==2
NormalVector[M_,r_]:=Transformation[M,ConjugatingElement[r],NormalVector[M,CentralGenerator[r]]]-Transformation[M,ConjugatingElement[r],ZeroVector[M]]/;WordLength[r]>1&&!M==TypeAE[1]


BasePoint[M_,r_]:=ZeroVector[M]/;SphericalCGQ[M]
BasePoint[M_,r_]:=WallGeneratorPairs[M][[r]][[1]]/;EuclideanCGQ[M]&&WordLength[r]==1
BasePoint[M_,r_]:=Transformation[M,ConjugatingElement[r],BasePoint[M,CentralGenerator[r]]]/;EuclideanCGQ[M]&&WordLength[r]>1


Options[CoxeterHyperplane]={
"Colour"->Gray,
"Thickness"->Thick,
"PointSize"->Medium,
"Opacity"->.2,
"UnderlyingSphere"->False,
"UnderlyingSphereColour"->White(*,
"HyperplaneLabels"\[Rule]False*)
};


CoxeterHyperplane[M_,r_,OptionsPattern[]]:={
PointSize[OptionValue["PointSize"]],
OptionValue["Colour"],
Point[Append[BasePoint[M,r],0]]
}/;M==TypeAE[1]
CoxeterHyperplane[M_,r_,OptionsPattern[]]:={
OptionValue["Colour"],
OptionValue["Thickness"],
Hyperplane[NormalVector[M,r],BasePoint[M,r]]
}/;EuclideanCGQ[M]&&VisualisationDimension[M]== 2
CoxeterHyperplane[M_,r_,OptionsPattern[]]:={
EdgeForm[],
OptionValue["Colour"],
Opacity["Opacity"],
Hyperplane[NormalVector[M,r],BasePoint[M,r]]
}/;EuclideanCGQ[M]&&VisualisationDimension[M]== 3
CoxeterHyperplane[M_,r_,OptionsPattern[]]:=Module[{point},
point=Transformation[M,ConjugatingElement[r],WallGeneratorPairs[M][[CentralGenerator[r]]]][[1]];
{
OptionValue["Colour"],
OptionValue["Thickness"],
Line[{point,-point}]
}
]/;SphericalCGQ[M]&&Length[M]==2
CoxeterHyperplane[M_,r_,OptionsPattern[]]:=Circle3D[
{0,0,0},
 NormalVector[M,r],
1.001,
OptionValue["Colour"],
OptionValue["Thickness"]
]/;SphericalCGQ[M]&&Length[M]==3


ShowHyperplanes[M_,rList_List,options___]:=Graphics[CoxeterHyperplane[M,#,options]&/@rList]/;(EuclideanCGQ[M]||SphericalCGQ[M])&&VisualisationDimension[M]<=2
ShowHyperplanes[M_,rList_List,options___]:=Show[CoxeterHyperplane[M,#,options]&/@rList]/;SphericalCGQ[M]&&VisualisationDimension[M]==3


ShowGalleries[args___]:=(Message[ShowGalleries::argerr];$Failed)
ShowGalleries[M_,wList_,options___]:=(Message[ShowGalleries::visualisation];$Failed)/;!VisualisableQ[M]
ShowGalleries[M_ "",options___]:=(Message[ShowGalleries::empty];$Failed)


Options[Gallery]={
"Colour"->Gray,
"Thickness"->Thick,
"Vertices"->False,
"PointSize"->Medium(*,
"GalleryLabels"\[Rule]False*)
};


Gallery[M_,w_String,OptionsPattern[]]:=
ListLinePlot[
If[
M==TypeAE[1],
Append[ChamberBarycentre[M,#],0.1],
ChamberBarycentre[M,#]
]&/@Table[WordTake[w,i],{i,0,WordLength[w]}],PlotStyle->Directive[OptionValue["Colour"],OptionValue["Thickness"]], 
Mesh->If[OptionValue["Vertices"],All,None],
MeshStyle->PointSize[OptionValue["PointSize"]],
Axes->False,
AspectRatio->1
]/;VisualisationDimension[M]==2&&(EuclideanCGQ[M]||SphericalCGQ[M])&&!w==""
Gallery[M_,w_String,OptionsPattern[]]:=
If[
OptionValue["Vertices"],
Show[
ListArcPlot3D[N[ChamberBarycentre[M,#]&/@Table[WordTake[w,i],{i,0,WordLength[w]}]],
1,
"path",
OptionValue["Colour"],
OptionValue["Thickness"]
],
ListPointPlot3D[
N[ChamberBarycentre[M,#]&/@Table[WordTake[w,i],{i,0,WordLength[w]}]],
PlotStyle->Directive[OptionValue["Colour"],PointSize[OptionValue["PointSize"]]],
Axes->False,
AspectRatio->1
]
],
ListArcPlot3D[N[ChamberBarycentre[M,#]&/@Table[WordTake[w,i],{i,0,WordLength[w]}]],
1,
"path",
OptionValue["Colour"],
OptionValue["Thickness"]
]
]/;VisualisationDimension[M]==3&&SphericalCGQ[M]&&!w==""


ShowGalleries[M_,wList_List,options___]:=Fold[
Show,
Gallery[M,#,options]&/@Complement[wList,{""}]
]


End[];


Protect[ShowChambers,ShowHyperplanes,ShowGalleries];


(*Protect[
(*Visualisabel*)
VisualisableQ,VisualisationDimension,
(*Euclidean geometry*)
EuclideanPoints,EuclideanReflection,EuclideanLineSegments,EuclideanPolygon,NormalVector,EuclideanReflection,EuclideanPolyhedron,
(*Spherical geometry*)
Bearing,SphericalArc,SphericalReflection,CircularArc3D,Circle3D,SphericalPolygon,SphericalReflection,
(*Hyperbolic geometry*)
(*Transformations*)
PointsToEdges,ChamberWalls,WallGeneratorPairs,Transformation,
(*Chambers*)
ChamberVertices,Chamber,ChamberBarycentre,ShowChambers,
(*Hyperplanes*)
ZeroVector,BasePoint,CoxeterHyperplane,ShowHyperplanes,
(*Galleries*)
Gallery,ShowGalleries
];*)


EndPackage[];
