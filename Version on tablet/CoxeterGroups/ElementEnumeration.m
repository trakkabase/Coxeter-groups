(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: ElementEnumeration *) 
(* :Author: David Sheard *)
(* :Summary: Functions to enumerate elements of a Coxeter system by length. *)
(* :Context: CoxeterGroups`ElementEnumeration` *)
(* :Package version: 1.0 *)
(* :History:  Version 1.0 February 28 2022 *)
(* :Mathematica version: 12.0.0 for Microsoft Windows (64-bit) (April 6, 2019) *)
(* :Discussion: Give more details here.*)


BeginPackage["CoxeterGroups`ElementEnumeration`",{"CoxeterGroups`BasicCoxeterFunctions`"}];


Unprotect[
(*Tits' solution to the word problem*)
TitsM1,TitsM2,CoxeterReduce,FindCoxeterReducedWord,TitsWordProblem,ReducibleWordQ,
(*Tits' solution to the word problem*)
TitsRepresentation,LinearWordProblem,
(*Functions on words*)
CoxeterLength,CoxeterLengthQ,DeleteRepeatedElements,CoxeterMultiply,
(*Group names*)
(*Group element storage*)
LengthEnumerated,EnumeratedQ,SmoothEnumeratedQ,ElementDirName, ExportElementList,
(*Enumeration by length*)
CoxeterGroupElements
];
ClearAll[
(*Tits' solution to the word problem*)
TitsM1,TitsM2,CoxeterReduce,FindCoxeterReducedWord,TitsWordProblem,ReducibleWordQ,
(*Tits' solution to the word problem*)
TitsRepresentation,LinearWordProblem,
(*Functions on words*)
CoxeterLength,CoxeterLengthQ,DeleteRepeatedElements,CoxeterMultiply,
(*Group names*)
(*Group element storage*)
LengthEnumerated,EnumeratedQ,SmoothEnumeratedQ,ElementDirName,ExportElementList,
(*Enumeration by length*)
CoxeterGroupElements
];


TitsM1::usage="TitsM1[w] applies all possible Tits moves of type M1 to w.";
TitsM2::usage="TitsM2[M,w] produces a list of all words accessible from w by up to one Tits move of type M2 in the Coxeter system accociated to M.
TitsM2[W,wList] produces a list of all words accessible from any word in wList by up to one Tits move of type M2 in the Coxeter system accociated to M.";
CoxeterReduce::usage="CoxeterReduce[M,w] produces a list of all possible reduced words representing w in the Coxeter system associated to M.";
FindCoxeterReducedWord::usage="FindCoxeterReducedWord[M,w] produces some reduced word representing w in the Coxeter system associated to M.";
TitsWordProblem::usage="TitsWordProblem[M, w, v] returns true if w and v are words representing the same element in the Coxeter system associated to M, False otherwie.";
ReducibleWordQ::usage="ReducibleWordQ[M, w] returns True is w represents an element of the Coxeter system associated to M which has shorter length than the string length of w.";


TitsRepresentation::usage="TitsRepresentation[M,w] gives the matrix by which the element w acts in the Tits represnetation of the Coxeter system asociated to M.";
LinearWordProblem::usage="LinearWordProblem[M,v,w] returns True if v and w are words representing the same element in the Coxeter system associated to M, and False otherwis.
LinearWordProblem[M,v,wList] returns True if v is a word representing the same element as some word in wList in the Coxeter system associated to M, and False otherwis.
LinearWordProblem[M,vList,w] returns True if w is a word representing the same element as some word in vList in the Coxeter system associated to M, and False otherwis.";


CoxeterLength::usage="CoxeterLength[M,w] gives the length of w with respect to the Coxeter generating set of the Coxeter system associated to M.";
CoxeterLengthQ::usage="CoxeterLengthQ[M, w, {k}] returns true if the length of w as an element of the Coxeter system associated to M equals k.
CoxeterLengthQ[M, w, k] returns true if the length of w as an element of the Coxeter system associated to M is at most k.";
DeleteRepeatedElements::usage="DeleteRepeatedElements[M,wList] removes words from wList which represent the same group elements in the Coxeter system associated to M as other words from the list.";
CoxeterMultiply::usage="CoxeterMultiply[M,v,w] returns a reduced word representing the element vw in the Coxeter system associated to M.";


GroupName::usage="GroupName[M] returns the name of the Coxeter system with matric M as a string. This is used for file naming when storing enumerated elements.";


LengthEnumerated::usage="LengthEnumerated[M] gives the maximum natural number such that all group elements of W(M) up to that length ahve been previously computed. If no elements have been computed it takes value -1.";
EnumeratedQ::usage="EnumeratedQ[M,k] returens True if LengthEnumerated[M] is at most k, and False otherwise.";
SmoothEnumeratedQ::usage="SmoothEnumeratedQ[M, {k}] returens True if there is a file in the directory SmoothDirName[M] with mane \"k.mx\", and False otherwise.";
ElementDirName::usage="ElementDirName[M, dataType] gives the path for the directory in GroupData\\dataType\\GroupName[M].";
ExportElementList::usage="ExportElementList[M, {k}, wordList, dataType] saves wordList to a file called \"k.mx\" in ElementDirName[M, dataType].";


CoxeterGroupElements::usage="CoxeterGroupElements[M, {k}] returns a list containing exactly one reduced word representing exach element of the Coxeter system associated to M whose length equals k.
CoxeterGroupElements[M, k] returns a list containing exactly one reduced word representing exach element of the Coxeter system associated to M whose length is at most k.";


TitsM1::argerr="One string argument expected.";
TitsM2::argerr="Two arguments expected.";
CoxeterReduce::argerr="Two arguments expected.";
FindCoxeterReducedWord::argerr="Two arguments expected.";
TitsWordProblem::argerr="Three arguments expected.";
ReducibleWordQ::argerr="Two arguments expected.";


TitsRepresentation::argerr="Two arguments expeacted.";
LinearWordProblem::argerr="Three arguments expected.";


CoxeterLength::argerr="Two arguments expected.";
CoxeterLengthQ::argerr="Three arguments expected.";
DeleteRepeatedElements::argerr="Two arguments expected.";
CoxeterMultiply::argerr="Three arguments expected.";


GroupName::argerr="One matrix argument expected.";
GroupName::undefined="You must declare a name for the group `1` as a string: groupName[`1`]=\"name\".";
GroupName::invalidGroupName="A the groupName must be a string containing the following characters only: upper and lower case Roman letters, Arabic numerals, spaces, or any of the following -_,.()";


LengthEnumerated::argerr="One matrix argument expected.";
EnumeratedQ::argerr="Two arguments expected.";
SmoothEnumeratedQ::argerr="Two arguments expected.";
ElementDirName::argerr="Two arguments expected.";
ElementDirName::dataType="The second argument must be \"GroupElements\" or \"SmoothElements\".";
ExportElementList::argerr="Four arguments expected.";
ExportElementList::dataType="The second argument must be \"GroupElements\" or \"SmoothElements\".";


CoxeterGroupElements::maxLength="`1` exceeds the maximum length of words in the group";
CoxeterGroupElements::infiniteLength="Cannot compute infinitely many group elements";
CoxeterGroupElements::argerr="Two arguments expected.";


Begin["`Private`"];


TitsM1[args___]:=(Message[TitsM1::argerr];$Failed)
TitsM2[args___]:=(Message[TitsM2::argerr];$Failed)
CoxeterReduce[args___]:=(Message[CoxeterReduce::argerr];$Failed)
FindCoxeterReducedWord[args___]:=(Message[FindCoxeterReducedWord::argerr];$Failed)
TitsWordProblem[args___]:=(Message[TitsWordProblem::argerr];$Failed)
ReducibleWordQ[args___]:=(Message[ReducibleWordQ::argerr];$Failed)


TitsM1[w_]:=Module[{moves},
moves=StringReplace[w,"s"~~x__~~"s"~~x__/;!StringContainsQ[x,"s"]->""];
If[
StringLength[moves]==StringLength[w],
w,
TitsM1[moves]
]
]


Locate[w_String,b_String]:={b,#}&/@StringPosition[w,b]


LocateAll[w_String,b_List]:=Fold[Join,Locate[w,#]&/@b]


InverseBraid[w_]:=Module[{sPos,first,second},
sPos=#[[1]]&/@StringPosition[w<>"s","s"];
first={sPos[[1]],sPos[[2]]-1};
second={sPos[[2]],sPos[[3]]-1};
CoxeterWordRewrite[w,{StringTake[w,first]->StringTake[w,second],StringTake[w,second]-> StringTake[w,first]}]
]


Relations[M_]:=Module[{all,depth,rel},
all=Table[{M[[i]][[j]],Generators[M][[i]],Generators[M][[j]]},{i,1,Length[M]},{j,1,Length[M]}];
depth=If[MemberQ[Flatten[all],Infinity],4,3];
rel=Select[Flatten[all,Depth[all]-depth],Not[#[[1]]==Infinity]&&Not[#[[1]]==1]&];
Relations[M]=Braid[#[[1]],#[[2]],#[[3]]]&/@rel
]


TitsM2[M_,w_String]:=
DeleteDuplicates[Join[{w},Flatten[StringReplaceList[w,#->InverseBraid[#]]&/@Relations[M]]]]
TitsM2[M_,wList_List]:=DeleteDuplicates[Join[wList,Fold[Join,TitsM2[M,#]&/@wList]]]


(* ::Input::Initialization:: *)
M1ReducibleWordQ[w_]:=StringContainsQ[w,"s"~~x__~~"s"~~x__/;!StringContainsQ[x,"s"]]
M1ReducibleWordQ[wList_List]:=Fold[Or,M1ReducibleWordQ[#]&/@wList]


ReducibleWordQ[M_,w_String]:=If[M1ReducibleWordQ[w],True,ReducibleWordQ[M,TitsM2[M,w]]]
ReducibleWordQ[M_,wList_List]:=If[Fold[Or,M1ReducibleWordQ[#]&/@wList],True,If[TitsM2[M,wList]==wList,False,ReducibleWordQ[M,TitsM2[M,wList]]]]


(* ::Input::Initialization:: *)
FindCoxeterReducibleWord[M_,wList_List]:=Select[wList,M1ReducibleWordQ[#]&,1][[1]](*gives an element of wList which contains a double letter*)


(* ::Input::Initialization:: *)
CoxeterReduce[M_,w_String]:=If[
M1ReducibleWordQ[w],
CoxeterReduce[M,TitsM1[w]],
CoxeterReduce[M,TitsM2[M,w]]
]
CoxeterReduce[M_,wList_List]:=CoxeterReduce[M,TitsM1[FindCoxeterReducibleWord[M,wList]]]/;M1ReducibleWordQ[wList]
CoxeterReduce[M_,wList_List]:=Module[{wList2},
wList2=TitsM2[M,wList];
If[
wList==wList2,
wList,
CoxeterReduce[M,wList2]
]
]/;Not[M1ReducibleWordQ[wList]]


(* ::Input::Initialization:: *)
FindCoxeterReducedWord[M_,w_]:=Sort[CoxeterReduce[M,w]][[1]]


TitsWordProblem[M_,w_,v_]:=MemberQ[CoxeterReduce[M,w],FindCoxeterReducedWord[M,v]]


TitsRepresentation[args___]:=(Message[TitsRepresentation::argerr];$Failed)
LinearWordProblem[args___]:=(Message[LinearWordProblem::argerr];$Failed)


TitsRepresentation[M_,w_String]:=IdentityMatrix[Length[M]]/;WordLength[w]==0
TitsRepresentation[M_,w_String]:=Module[{i},
i=GeneratorIndex[w];
ArrayFlatten[{Table[Transpose[{UnitVector[Length[M],j]-2BilinearForm[M][[i]][[j]]UnitVector[Length[M],i]}],{j,Length[M]}]}] 
]/;WordLength[w]==1
TitsRepresentation[M_,w_String]:=Module[{i},
i=StringLength[w]-Last[StringPosition[w,"s"]][[1]]+1;
Simplify[Dot[TitsRepresentation[M,StringTake[w,-i]],TitsRepresentation[M,StringDrop[w,-i]]]]
]/;WordLength[w]>1


TitsRepresentation[M_,{k_Integer}]:=Values[Import[FileNameJoin[{ElementDirName[M,"GroupElements"],ToString[k]<>".mx"}]]]/;EnumeratedQ[M,k]
TitsRepresentation[M_,{0}]:=TitsRepresentation[M,""]/;!EnumeratedQ[M,0]
TitsRepresentation[M_,{1}]:=TitsRepresentation[M,#]&/@Generators[M]/;!EnumeratedQ[M,1]
TitsRepresentation[M_,{k_Integer}]:=Module[{first},
CoxeterGroupElements[M,{k}];
TitsRepresentation[M,{k}]
]/;!EnumeratedQ[M,k]&&k>=2
TitsRepresentation[M_,k_Integer]:=Fold[Join,Table[TitsRepresentation[M,{i}],{i,0,k}]]


LinearWordProblem[M_,v_String,w_String]:=TitsRepresentation[M,v]==TitsRepresentation[M,w]
LinearWordProblem[M_,v_String,wList_List]:=MemberQ[TitsRepresentation[M,#]&/@wList,TitsRepresentation[M,v]]
LinearWordProblem[M_,vList_List,w_String]:=LinearWordProblem[M,w,vList]


CoxeterLength[args___]:=(Message[CoxeterLength::argerr];$Failed)
CoxeterLengthQ[args___]:=(Message[CoxeterLengthQ::argerr];$Failed)
DeleteRepeatedElements[args___]:=(Message[DeleteRepeatedElements::argerr];$Failed)
CoxeterMultiply[args___]:=(Message[CoxeterMultiply::argerr];$Failed)


(* ::Input::Initialization:: *)
CoxeterLength[M_,w_]:=WordLength[FindCoxeterReducedWord[M,w]]


CoxeterLengthQ[M_,w_,k_]:=MemberQ[TitsRepresentation[M,k],TitsRepresentation[M,w]]


DeleteRepeatedElements[M_,wList_List]:=DeleteDuplicatesBy[wList,TitsRepresentation[M,#]&]


CoxeterMultiply[M_,u_,v_]:=FindCoxeterReducedWord[M,u<>v]


GroupName[args___]:=(Message[GroupName::argerr];$Failed)


GroupName[M_]:="A_"<>ToString[Length[M]]/;M==TypeA[Length[M]]
GroupName[M_]:="B_"<>ToString[Length[M]]/;M==TypeB[Length[M]]
GroupName[M_]:="D_"<>ToString[Length[M]]/;M==TypeD[Length[M]]
GroupName[E6]="E_6";
GroupName[E7]="E_7";
GroupName[E8]="E_8";
GroupName[F4]="F_4";
GroupName[G2]="G_2";
GroupName[H3]="H_3";
GroupName[H4]="H_4";
GroupName[M_]:="I_2("<>ToString[M[[1]][[2]]]<>")"/;Length[M]==2&&!MemberQ[{I2[3],I2[4],I2[6]},M]&&ValidCoxeterMatrixQ[M]
GroupName[M_]:="AE_"<>ToString[Length[M]-1]/;M==TypeAE[Length[M]-1]
GroupName[TypeBE[2]]="BE_2";
GroupName[M_]:="BE_"<>ToString[Length[M]-1]/;M==TypeBE[Length[M]-1]
GroupName[M_]:="CE_"<>ToString[Length[M]-1]/;M==TypeCE[Length[M]-1]
GroupName[M_]:="DE_"<>ToString[Length[M]-1]/;M==TypeDE[Length[M]-1]
GroupName[EE6]="EE_6";
GroupName[EE7]="EE_7";
GroupName[EE8]="EE_8";
GroupName[EE8]="EE_8";
GroupName[FE4]="FE_4";
GroupName[GE2]="GE_2";
GroupName[M_]:="TriangleCG("<>ToString[M[[1]][[3]]]<>","<>ToString[M[[1]][[2]]]<>","<>ToString[M[[2]][[3]]]<>")"/;Length[M]==3&&HyperbolicCGQ[M]&&ValidCoxeterMatrixQ[M]
GroupName[M_]:="FreeCG_"<>ToString[Length[M]]/;M==FreeCG[Length[M]]&&Length[M]>1
GroupName[M_]:="RAPolygonG_"<>ToString[Length[M]]/;M==RAPolygonG[Length[M]]&&Length[M]>=4
GroupName[M_]:=Module[{m,n},
n=Length[Select[M[[1]],#==2&]];
m=Length[M]-n;
"RABipartiteG_("<>ToString[n]<>","<>ToString[m]<>")"/;M==RABipartiteG[n,m]&&Length[M]>3
]


LengthEnumerated[args___]:=(Message[LengthEnumerated::argerr];$Failed)
EnumeratedQ[args___]:=(Message[EnumeratedQ::argerr];$Failed)
SmoothEnumeratedQ[args___]:=(Message[SmoothEnumeratedQ::argerr];$Failed)
ElementDirName[args___]:=(Message[ElementDirName::argerr];$Failed)
ExportElementList[args___]:=(Message[ExportElementList::argerr];$Failed)


StringCharacters[name_]:=DeleteDuplicates[Table[StringTake[name,{i}],{i,1,StringLength[name]}]]


ValidCharacters[]:={"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","B","O","P","Q","R","S","T","U","V","W","X","Y","Z","0","1","2","3","4","5","6","7","8","9"," ","-","_",",",".","(",")"}


ValidFileNameQ[name_]:=If[SubsetQ[ValidCharacters[],StringCharacters[name]],True,
Module[{},
Message[GroupName::invalidGroupName];
False
]
]


NamedQ[M_]:=If[StringQ[GroupName[M]],True,
Module[{},
Message[GroupName::undefined,M];
False
]
]


ElementDirName[M_,dataType_]:=FileNameJoin[{$UserBaseDirectory,"Applications","CoxeterGroups","GroupData",dataType,GroupName[M]}]/;MemberQ[{"GroupElements","GroupElements2","SmoothElements","SommthElements2"},dataType]&&NamedQ[M]&&ValidFileNameQ[GroupName[M]]
ElementDirName[M_,dataType_]:=(Message[ElementDirName::dataType];$Failed)/;!MemberQ[{"GroupElements","GroupElements2","SmoothElements","SommthElements2"},dataType]


ElementDirExistQ[M_,dataType_]:=DirectoryQ[ElementDirName[M,dataType]]


CreateElementDir[M_,dataType_]:=CreateDirectory[ElementDirName[M,dataType]]


ExportElementList[M_,{k_},assoc_,"GroupElements"]:=Module[{},
If[Not[ElementDirExistQ[M,"GroupElements"]],CreateElementDir[M,"GroupElements"],Null];
Export[FileNameJoin[{ElementDirName[M,"GroupElements"],"0.mx"}],<|""->TitsRepresentation[M,""]|>];
Export[FileNameJoin[{ElementDirName[M,"GroupElements"],"1.mx"}],Association[#->TitsRepresentation[M,#]&/@Generators[M]]];
Export[FileNameJoin[{ElementDirName[M,"GroupElements"],"2.mx"}],assoc]
]/;k==2
ExportElementList[M_,{k_},assoc_,"GroupElements"]:=
Export[FileNameJoin[{ElementDirName[M,"GroupElements"],ToString[k]<>".mx"}],assoc]/;k>=3


ExportElementList[M_,{k_},wordList_,"SmoothElements"]:=Module[{},
If[
!ElementDirExistQ[M,"SmoothElements"],
CreateElementDir[M,"SmoothElements"],
Null
];
Export[FileNameJoin[{ElementDirName[M,"SmoothElements"],ToString[k]<>".mx"}],wordList]
]


ExportElementList[M_,{k_},wordAssoc_,"GroupElements2"]:=Module[{},
If[
!ElementDirExistQ[M,"GroupElements2"],
CreateElementDir[M,"GroupElements2"],
Null
];
Export[FileNameJoin[{ElementDirName[M,"GroupElements2"],ToString[k]<>".mx"}],wordAssoc]
]


ExportElementList[M_,{k_},wordList_,dataType_]:=(Message[ExportElementList::dataType];$Failed)/;!MemberQ[{"GroupElements","GroupElements2","SmoothElements","SommthElements2"},dataType]


ExportElementList[M_,{k_},wordList_,"SmoothElements2"]:=Module[{},
If[
!ElementDirExistQ[M,"SmoothElements2"],
CreateElementDir[M,"SmoothElements2"],
Null
];
Export[FileNameJoin[{ElementDirName[M,"SmoothElements2"],ToString[k]<>".mx"}],wordList]
]


LengthEnumerated[M_]:=Module[{output},
Off[GroupName::argerr];
output=If[
NamedQ[M],
If[
ElementDirExistQ[M,"GroupElements"],
Max[ToExpression[StringDrop[FileNameTake[#,-1],-3]]&/@FileNames[All,ElementDirName[M,"GroupElements"]]],
-1
],
-1
];
On[GroupName::argerr];
output
]


EnumeratedQ[M_,k_]:=k<=LengthEnumerated[M]


SmoothEnumeratedQ[M_,{k_}]:=FileExistsQ[FileNameJoin[{ElementDirName[M,"SmoothElements"],ToString[k]<>".mx"}]]


CoxeterGroupElements[args___]:=(Message[CoxeterGroupElements::argerr];$Failed)
CoxeterGroupElements[M_,Infinity]:=(Message[CoxeterGroupElements::infiniteLength];$Failed)


CoxeterGroupElements[M_,{0}]:={""}
CoxeterGroupElements[M_,{1}]:=Generators[M]
CoxeterGroupElements[M_,{k_}]:=Module[{freeWords,irreducibleWords,newWords,assoc},
freeWords=Flatten[
Table[
CoxeterGroupElements[M,{k-1}][[i]]<>CoxeterGroupElements[M,{1}][[j]],
{i,1,Length[CoxeterGroupElements[M,{k-1}]]},
{j,1,Length[CoxeterGroupElements[M,{1}]]}
]
];
irreducibleWords=Select[freeWords,Not[LinearWordProblem[M,#,CoxeterGroupElements[M,{k-2}]]]&](*this is quite inefficient*);
newWords=DeleteRepeatedElements[M,irreducibleWords];
assoc=Association[#->TitsRepresentation[M,#]&/@newWords];
ExportElementList[M,{k},assoc,"GroupElements"];
newWords
]/;2<= k<= MaxLength[M]&&!EnumeratedQ[M,k]
CoxeterGroupElements[M_,0]:=CoxeterGroupElements[M,{0}]
CoxeterGroupElements[M_,k_Integer]:=If[
k<=MaxLength[M],
(On[CoxeterGroupElements::maxLength];Join[CoxeterGroupElements[M,k-1],CoxeterGroupElements[M,{k}]]),
(Message[CoxeterGroupElements::maxLength,k];Off[CoxeterGroupElements::maxLength];CoxeterGroupElements[M,k-1])
]


CoxeterGroupElements[M_,{k_}]:=Keys[Import[FileNameJoin[{ElementDirName[M,"GroupElements"],ToString[k]<>".mx"}]]]/;EnumeratedQ[M,k]
CoxeterGroupElements[M_,{k_}]:=(Message[CoxeterGroupElements::maxLength,k];{})/;k>MaxLength[M]


End[];


Protect[
(*Tits' solution to the word problem*)
TitsM1,TitsM2,CoxeterReduce,FindCoxeterReducedWord,TitsWordProblem,ReducibleWordQ,
(*Tits' solution to the word problem*)
TitsRepresentation,LinearWordProblem,
(*Functions on words*)
CoxeterLength,CoxeterLengthQ,DeleteRepeatedElements,CoxeterMultiply,
(*Group names*)
(*Group element storage*)
LengthEnumerated,EnumeratedQ,SmoothEnumeratedQ,ElementDirName,ExportElementList,
(*Enumeration by length*)
CoxeterGroupElements
];


EndPackage[];
